!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/kensuke/workspace/c_cpp/utils/applyPatch/ap/include/utils/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210905.0/
DIRECTORY_NOT_EXIST	err.hpp	/^        DIRECTORY_NOT_EXIST$/;"	e	enum:ap::ERR_CODE	access:public
DIRECTORY_NOT_EXIST	err.hpp	/^        std::map<char, std::string> DIRECTORY_NOT_EXIST;$/;"	m	struct:ap::__anon748f99640108	typeref:typename:std::map<char,std::string>	access:public
ERR_CODE	err.hpp	/^    enum class ERR_CODE {$/;"	g	namespace:ap
ERR_MSG	err.hpp	/^    } ERR_MSG = {$/;"	v	namespace:ap	typeref:typename:const struct ap::__anon748f99640108
FILE_NOT_EXIST	err.hpp	/^        FILE_NOT_EXIST,$/;"	e	enum:ap::ERR_CODE	access:public
FILE_NOT_EXIST	err.hpp	/^        std::map<char, std::string> FILE_NOT_EXIST;$/;"	m	struct:ap::__anon748f99640108	typeref:typename:std::map<char,std::string>	access:public
File	file.cpp	/^ap::File::File(std::string &tgt_path, std::string &src_path) {$/;"	f	class:ap::File	signature:(std::string & tgt_path,std::string & src_path)
File	file.hpp	/^        File(std::string &tgt_path, std::string &src_path);$/;"	p	class:ap::File	access:public	signature:(std::string & tgt_path,std::string & src_path)
File	file.hpp	/^    class File {$/;"	c	namespace:ap
NO_ERROR	err.hpp	/^        NO_ERROR,$/;"	e	enum:ap::ERR_CODE	access:public
PatchUtils	patchUtils.hpp	/^        PatchUtils(){};$/;"	f	class:ap::PatchUtils	access:public	signature:()
PatchUtils	patchUtils.hpp	/^    class PatchUtils {$/;"	c	namespace:ap
__anon748f99640108	err.hpp	/^    const struct {$/;"	s	namespace:ap
ap	err.hpp	/^namespace ap {$/;"	n
ap	file.hpp	/^namespace ap {$/;"	n
ap	patchUtils.hpp	/^namespace ap {$/;"	n
ap::DIRECTORY_NOT_EXIST	err.hpp	/^        DIRECTORY_NOT_EXIST$/;"	e	enum:ap::ERR_CODE	access:public
ap::ERR_CODE	err.hpp	/^    enum class ERR_CODE {$/;"	g	namespace:ap
ap::ERR_MSG	err.hpp	/^    } ERR_MSG = {$/;"	v	namespace:ap	typeref:typename:const struct ap::__anon748f99640108
ap::FILE_NOT_EXIST	err.hpp	/^        FILE_NOT_EXIST,$/;"	e	enum:ap::ERR_CODE	access:public
ap::File	file.hpp	/^    class File {$/;"	c	namespace:ap
ap::File::File	file.cpp	/^ap::File::File(std::string &tgt_path, std::string &src_path) {$/;"	f	class:ap::File	signature:(std::string & tgt_path,std::string & src_path)
ap::File::File	file.hpp	/^        File(std::string &tgt_path, std::string &src_path);$/;"	p	class:ap::File	access:public	signature:(std::string & tgt_path,std::string & src_path)
ap::File::check_if_file_exists	file.cpp	/^bool ap::File::check_if_file_exists(std::string &file) {$/;"	f	class:ap::File	typeref:typename:bool	signature:(std::string & file)
ap::File::check_if_file_exists	file.hpp	/^        bool check_if_file_exists(std::string &file);$/;"	p	class:ap::File	typeref:typename:bool	access:public	signature:(std::string & file)
ap::File::fcopy	file.cpp	/^void ap::File::fcopy(std::string &src_file, std::string &dst_file) {$/;"	f	class:ap::File	typeref:typename:void	signature:(std::string & src_file,std::string & dst_file)
ap::File::fcopy	file.hpp	/^        void fcopy(std::string &src_file, std::string &dst_file);$/;"	p	class:ap::File	typeref:typename:void	access:public	signature:(std::string & src_file,std::string & dst_file)
ap::File::fmove	file.cpp	/^void ap::File::fmove(std::string &src_file, std::string &dst_file) {$/;"	f	class:ap::File	typeref:typename:void	signature:(std::string & src_file,std::string & dst_file)
ap::File::fmove	file.hpp	/^        void fmove(std::string &src_file, std::string &dst_file);$/;"	p	class:ap::File	typeref:typename:void	access:public	signature:(std::string & src_file,std::string & dst_file)
ap::File::get_patch_path	file.cpp	/^std::string ap::File::get_patch_path() {$/;"	f	class:ap::File	typeref:typename:std::string	signature:()
ap::File::get_patch_path	file.hpp	/^        std::string get_patch_path();$/;"	p	class:ap::File	typeref:typename:std::string	access:public	signature:()
ap::File::get_src_path	file.cpp	/^std::string ap::File::get_src_path() {$/;"	f	class:ap::File	typeref:typename:std::string	signature:()
ap::File::get_src_path	file.hpp	/^        std::string get_src_path();$/;"	p	class:ap::File	typeref:typename:std::string	access:public	signature:()
ap::File::list_files	file.cpp	/^std::vector<std::string> ap::File::list_files(std::string &path) {$/;"	f	class:ap::File	typeref:typename:std::vector<std::string>	signature:(std::string & path)
ap::File::list_files	file.hpp	/^        std::vector<std::string> list_files(std::string &path);$/;"	p	class:ap::File	typeref:typename:std::vector<std::string>	access:public	signature:(std::string & path)
ap::File::patch_path	file.hpp	/^        std::string patch_path;$/;"	m	class:ap::File	typeref:typename:std::string	access:private
ap::File::src_path	file.hpp	/^        std::string src_path;$/;"	m	class:ap::File	typeref:typename:std::string	access:private
ap::File::~File	file.hpp	/^        ~File(){};$/;"	f	class:ap::File	access:public	signature:()
ap::NO_ERROR	err.hpp	/^        NO_ERROR,$/;"	e	enum:ap::ERR_CODE	access:public
ap::PatchUtils	patchUtils.hpp	/^    class PatchUtils {$/;"	c	namespace:ap
ap::PatchUtils::PatchUtils	patchUtils.hpp	/^        PatchUtils(){};$/;"	f	class:ap::PatchUtils	access:public	signature:()
ap::PatchUtils::applyPatch	patchUtils.cpp	/^int ap::PatchUtils::applyPatch(const std::string &tgt_path,$/;"	f	class:ap::PatchUtils	typeref:typename:int	signature:(const std::string & tgt_path,const std::string & src_path)
ap::PatchUtils::applyPatch	patchUtils.hpp	/^        int applyPatch(const std::string &tgt_path,$/;"	p	class:ap::PatchUtils	typeref:typename:int	access:public	signature:(const std::string & tgt_path,const std::string & src_path)
ap::PatchUtils::date	patchUtils.hpp	/^        std::string date;$/;"	m	class:ap::PatchUtils	typeref:typename:std::string	access:private
ap::PatchUtils::get_today	patchUtils.cpp	/^std::string ap::PatchUtils::get_today() {$/;"	f	class:ap::PatchUtils	typeref:typename:std::string	signature:()
ap::PatchUtils::get_today	patchUtils.hpp	/^        std::string get_today();$/;"	p	class:ap::PatchUtils	typeref:typename:std::string	access:public	signature:()
ap::PatchUtils::split_string_by_delimiter	patchUtils.cpp	/^std::vector<std::string> ap::PatchUtils::split_string_by_delimiter($/;"	f	class:ap::PatchUtils	typeref:typename:std::vector<std::string>	signature:(const std::string & str,const char & delimiter)
ap::PatchUtils::split_string_by_delimiter	patchUtils.hpp	/^        std::vector<std::string> split_string_by_delimiter($/;"	p	class:ap::PatchUtils	typeref:typename:std::vector<std::string>	access:private	signature:(const std::string & str,const char & delimiter)
ap::PatchUtils::~PatchUtils	patchUtils.hpp	/^        ~PatchUtils(){};$/;"	f	class:ap::PatchUtils	access:public	signature:()
ap::__anon748f99640108	err.hpp	/^    const struct {$/;"	s	namespace:ap
ap::__anon748f99640108::DIRECTORY_NOT_EXIST	err.hpp	/^        std::map<char, std::string> DIRECTORY_NOT_EXIST;$/;"	m	struct:ap::__anon748f99640108	typeref:typename:std::map<char,std::string>	access:public
ap::__anon748f99640108::FILE_NOT_EXIST	err.hpp	/^        std::map<char, std::string> FILE_NOT_EXIST;$/;"	m	struct:ap::__anon748f99640108	typeref:typename:std::map<char,std::string>	access:public
ap_pkg	CMakeLists.txt	/^add_library(ap_pkg$/;"	t
applyPatch	patchUtils.cpp	/^int ap::PatchUtils::applyPatch(const std::string &tgt_path,$/;"	f	class:ap::PatchUtils	typeref:typename:int	signature:(const std::string & tgt_path,const std::string & src_path)
applyPatch	patchUtils.hpp	/^        int applyPatch(const std::string &tgt_path,$/;"	p	class:ap::PatchUtils	typeref:typename:int	access:public	signature:(const std::string & tgt_path,const std::string & src_path)
check_if_file_exists	file.cpp	/^bool ap::File::check_if_file_exists(std::string &file) {$/;"	f	class:ap::File	typeref:typename:bool	signature:(std::string & file)
check_if_file_exists	file.hpp	/^        bool check_if_file_exists(std::string &file);$/;"	p	class:ap::File	typeref:typename:bool	access:public	signature:(std::string & file)
date	patchUtils.hpp	/^        std::string date;$/;"	m	class:ap::PatchUtils	typeref:typename:std::string	access:private
fcopy	file.cpp	/^void ap::File::fcopy(std::string &src_file, std::string &dst_file) {$/;"	f	class:ap::File	typeref:typename:void	signature:(std::string & src_file,std::string & dst_file)
fcopy	file.hpp	/^        void fcopy(std::string &src_file, std::string &dst_file);$/;"	p	class:ap::File	typeref:typename:void	access:public	signature:(std::string & src_file,std::string & dst_file)
fmove	file.cpp	/^void ap::File::fmove(std::string &src_file, std::string &dst_file) {$/;"	f	class:ap::File	typeref:typename:void	signature:(std::string & src_file,std::string & dst_file)
fmove	file.hpp	/^        void fmove(std::string &src_file, std::string &dst_file);$/;"	p	class:ap::File	typeref:typename:void	access:public	signature:(std::string & src_file,std::string & dst_file)
get_patch_path	file.cpp	/^std::string ap::File::get_patch_path() {$/;"	f	class:ap::File	typeref:typename:std::string	signature:()
get_patch_path	file.hpp	/^        std::string get_patch_path();$/;"	p	class:ap::File	typeref:typename:std::string	access:public	signature:()
get_src_path	file.cpp	/^std::string ap::File::get_src_path() {$/;"	f	class:ap::File	typeref:typename:std::string	signature:()
get_src_path	file.hpp	/^        std::string get_src_path();$/;"	p	class:ap::File	typeref:typename:std::string	access:public	signature:()
get_today	patchUtils.cpp	/^std::string ap::PatchUtils::get_today() {$/;"	f	class:ap::PatchUtils	typeref:typename:std::string	signature:()
get_today	patchUtils.hpp	/^        std::string get_today();$/;"	p	class:ap::PatchUtils	typeref:typename:std::string	access:public	signature:()
list_files	file.cpp	/^std::vector<std::string> ap::File::list_files(std::string &path) {$/;"	f	class:ap::File	typeref:typename:std::vector<std::string>	signature:(std::string & path)
list_files	file.hpp	/^        std::vector<std::string> list_files(std::string &path);$/;"	p	class:ap::File	typeref:typename:std::vector<std::string>	access:public	signature:(std::string & path)
patch_path	file.hpp	/^        std::string patch_path;$/;"	m	class:ap::File	typeref:typename:std::string	access:private
split_string_by_delimiter	patchUtils.cpp	/^std::vector<std::string> ap::PatchUtils::split_string_by_delimiter($/;"	f	class:ap::PatchUtils	typeref:typename:std::vector<std::string>	signature:(const std::string & str,const char & delimiter)
split_string_by_delimiter	patchUtils.hpp	/^        std::vector<std::string> split_string_by_delimiter($/;"	p	class:ap::PatchUtils	typeref:typename:std::vector<std::string>	access:private	signature:(const std::string & str,const char & delimiter)
src_path	file.hpp	/^        std::string src_path;$/;"	m	class:ap::File	typeref:typename:std::string	access:private
uint	patchUtils.cpp	/^    typedef unsigned int uint;$/;"	t	function:ap::PatchUtils::applyPatch	typeref:typename:unsigned int	file:
uint	patchUtils.cpp	/^    typedef unsigned int uint;$/;"	t	function:ap::PatchUtils::get_today	typeref:typename:unsigned int	file:
~File	file.hpp	/^        ~File(){};$/;"	f	class:ap::File	access:public	signature:()
~PatchUtils	patchUtils.hpp	/^        ~PatchUtils(){};$/;"	f	class:ap::PatchUtils	access:public	signature:()
